---
title: 网络基础
date: 2024-03-14T09:26:24+08:00
authors:
  - name: wylu
    link: https://github.com/wylu1037
    image: https://github.com/wylu1037.png?size=40
weight: 1
---

## 1.TCP/IP 四层模型

对于同一台设备上的进程间通信（IPC），有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套通用的网络协议。

### 1.1 应用层

最上层的，也是我们能直接接触到的就是{{< font "blue" "应用层（Application Layer）">}}，我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。

所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP 等。而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。

### 1.2 传输层

应用层的数据包会传给传输层，{{< font "blue" "传输层（Transport Layer）">}}是为应用层提供网络支持的。
{{< image "/images/docs/interview/network/应用层与传输层.webp" "传输层" >}}

在传输层会有两个传输协议，分别是 TCP 和 UDP。

TCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。

UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以（参考 HTTP3 的 QUIC 协议）。

应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（Maximum Segment Size，TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，把每个分块称为一个 {{< font "blue" "TCP 段（TCP Segment）" >}}。

{{< image "/images/docs/interview/network/TCP段.webp" "TCP段" >}}

当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是 **端口**。

比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。由于 **传输层** 的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

### 1.3 网络层

传输层不负责将数据从一个设备传输到另一个设备，传输层的设计理念是简单、高效、专注，专注于服务好应用，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是 {{< font "blue" "网络层（Internet Layer）" >}}。

{{< image "/images/docs/interview/network/网络层.webp" "网络层" >}}

网络层最常使用的是 {{< font "blue" "IP 协议（Internet Protocol）" >}}，IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（Maximum Transmission Unit，以太网中一般为 1500 字节）就会 **再次进行分片**，得到一个即将发送到网络的 IP 报文。

{{< image "/images/docs/interview/network/网络层数据传输.webp" "网络层数据传输.webp" >}}

网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。

一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。

因此，需要将 IP 地址分成两种意义：

- 一个是{{< font "blue" "网络号" >}}，负责标识该 IP 地址是属于哪个 <u>**子网**</u> 的；
- 一个是{{< font "blue" "主机号" >}}，负责标识同一 <u>**子网**</u> 下的不同主机；

<h5>怎么分的呢？这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。</h5>

举个例子，比如 10.100.122.0/24，后面的`/24`表示就是 255.255.255.0 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，是 24 个 1，为了简化子网掩码的表示，用/24 代替 255.255.255.0。

<h5>知道了子网掩码，该怎么计算出网络地址和主机地址呢？</h5>

将 10.100.122.2 和 255.255.255.0 进行 {{< font "blue" "按位与运算" >}}，就可以得到网络号，如下图：
{{< image "/images/docs/interview/network/计算网络号.webp" "计算网络号" >}}

将 255.255.255.0 取反后与 IP 地址进行进行 {{< font "blue" "按位与运算" >}}，就可以得到 **主机号**。

除了寻址能力， IP 协议还有另一个重要的能力就是路由。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。

路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

{{< image "/images/docs/interview/network/路由.webp" "路由" >}}

所以，{{< font "blue" "IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。">}}

### 1.4 链路层

生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。
{{< image "/images/docs/interview/network/网络接口层.webp" "网络接口层" >}}

IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

什么是以太网呢？电脑上的以太网接口，Wi-Fi 接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。

以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。

所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

### 1.5 总结

{{< image "/images/docs/interview/network/四层封装.webp" "四层封装" >}}

网络接口层的传输单位是 {{< font "blue" "帧（frame）">}}，IP 层的传输单位是 {{< font "blue" "包（packet）">}}，TCP 层的传输单位是 {{< font "blue" "段（segment）">}}，HTTP 的传输单位则是 {{< font "blue" "消息或报文（message）">}}。但这些名词并没有什么本质的区分，可以统称为数据包。

## 2.OSI 七层模型

开放式系统互联参考模型（Open System Interconnect Reference Model）

{{< image "/images/docs/interview/network/osi-model.png" "OSI 七层模型" >}}

## 3.键入网址到网页显示

## 4.Linux 系统是如何收发网络包的

### 4.1 网络模型

为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（Open System Interconnection Reference Model），也就是 OSI 网络模型，该模型主要有 7 层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。

由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。事实上，比较常见也比较实用的是四层模型，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。

TCP/IP 网络模型共有 4 层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：

- 应用层，负责向用户提供一组应用程序，比如 HTTP、DNS、FTP 等;
- 传输层，负责端到端的通信，比如 TCP、UDP 等；
- 网络层，负责网络包的封装、分片、路由、转发，比如 IP、ICMP 等；
- 网络接口层，负责网络包在物理网络中的传输，比如网络包的封帧、 MAC 寻址、差错检测，以及通过网卡传输网络帧等；

TCP/IP 网络模型相比 OSI 网络模型简化了不少，也更加易记，它们之间的关系如下图：

### 4.2 Linux 网络协议栈

Linux 网络协议栈的样子类似于 TCP/IP 的四层结构：

{{< image "/images/docs/interview/network/网络协议栈.webp" "网络协议栈" >}}

从上图的的网络协议栈，可以看到：

- 应用程序需要通过系统调用，来跟 Socket 层进行数据交互；
- Socket 层的下面就是传输层、网络层和网络接口层；
- 最下面的一层，则是网卡驱动程序和硬件网卡设备；

### 4.3 Linux 接收网络包的流程

### 4.4 Linux 发送网络包的流程

### 4.5 总结
