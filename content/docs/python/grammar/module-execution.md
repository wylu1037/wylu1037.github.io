---
title: 模块执行
date: 2025-07-31T09:25:09+08:00
authors:
  - name: wylu
    link: https://github.com/wylu1037
    image: https://github.com/wylu1037.png?size=40
---

在 Python 中，一个文件（`.py`）既可以作为独立的脚本直接运行，也可以作为模块被其他代码导入。区分这两种行为的关键在于内置变量 `__name__` 的值。

## `__name__` 变量

-   **当文件被直接执行时**：Python 解释器会将该文件的 `__name__` 变量设置为字符串 `"__main__"`。
-   **当文件被导入时**：`__name__` 会被设置为模块自身的名称（即文件名，不含 `.py` 后缀）。

`if __name__ == "__main__":` 这个条件判断语句就是利用这一机制，来包裹那些只应在脚本直接运行时才执行的代码。

## 不同执行方式的对比

下表总结了 Python 中几种主要执行方式的区别：

| 执行方式 | `__name__` 值 | `sys.path` 处理 | `if __main__` 块 | 典型场景 |
| :--- | :--- | :--- | :--- | :--- |
| `python run.py` | `"__main__"` | **不添加**脚本所在目录 | ✅ **执行** | 直接运行一个独立的脚本或应用程序入口。 |
| `python -m module` | `"__main__"` | **添加**当前工作目录到路径 | ✅ **执行** | 运行项目中的模块或标准库模块，确保模块路径正确。 |
| `import module` | `"module"` | 依赖现有的 `sys.path` | ❌ **不执行** | 在代码中导入并复用另一个模块的功能。 |

### 关键点解读

1.  **`python run.py`**：
    -   这是最直接的执行方式。
    -   Python 不会自动将 `run.py` 所在的目录添加到 `sys.path`。这意味着 `run.py` 内部的导入语句（`import ...`）需要依赖 Python 的标准路径查找规则。如果需要导入同级目录下的其他模块，可能会遇到 `ModuleNotFoundError`，除非当前工作目录恰好就是脚本所在的目录。

2.  **`python -m module`**：
    -   `-m` 开关告诉 Python 将一个模块作为脚本来运行。
    -   它最大的优势是**会将当前工作目录（你执行命令时所在的目录）自动添加到 `sys.path` 的开头**。这解决了相对导入的路径问题，使得它成为在复杂项目中运行模块的推荐方式。
    -   常用于运行包（package）中的模块，例如 `python -m my_project.main`。

3.  **`import module`**：
    -   这是最纯粹的模块复用方式。
    -   `__name__` 被设为模块名，因此 `if __name__ == "__main__":` 下的代码块不会执行，防止了在导入时意外执行代码。
    -   模块的查找完全依赖于 `sys.path` 中已有的路径。
